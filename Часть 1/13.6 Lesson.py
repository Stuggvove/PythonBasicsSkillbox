# Задача 1. Урок информатики 2.

# В прошлый раз учитель написал программу,
# которая выводит числа в формате плавающей точки, однако он вспомнил,
# что не учёл одну важную штуку: числа-то могут идти от нуля.
# 
# Задано положительное число x (x > 0).
# Ваша задача преобразовать его в формат плавающей точки,
# то есть x = a * 10 ** b, где 1 ≤ а < 10
# 
# Обратите внимание, что x теперь больше нуля, а не больше единицы.
# Обеспечьте контроль ввода.
# 
# Пример 1:
# 
# Введите число: 92345
# 
# Формат плавающей точки: x = 9.2345 * 10 ** 4
# 
# Пример 2:
# 
# Введите число: 0.0012
# Формат плавающей точки: x = 1.2 * 10 ** -3

def up_zero(num_user):
    count = 0
    while num_user > 10:
        num_user /= 10
        count += 1
    print(f'Формат плавающей точки: x = {num_user} * 10 ** {count}')

def down_zero(num_user):
    count = 0
    while num_user < 1:
        count -= 1
        num_user *= 10
    print(f'Формат плавающей точки: x = {round(num_user, 1)} * 10 ** {count}')


num_user = float(input('Введите число: '))

if num_user == 0:
    print('Введено некорректное значение.')
elif num_user > 1:
    up_zero(num_user)
else:
    down_zero(num_user)

# Задача 2. Функция максимума.

# Юра пишет различные полезные функции для Python,
# чтобы остальным программистам стало проще работать.
# Он захотел написать функцию, которая будет находить максимум из перечисленных чисел.
# Функция для нахождения максимума из двух чисел у него уже есть. Юра задумался: может быть,
# её можно как-то использовать для нахождения максимума уже от трёх чисел?

# Помогите Юре написать программу, которая находит максимум из трёх чисел.
# Для этого используйте только функцию нахождения максимума из двух чисел.

# По итогу в программе должны быть реализованы две функции:
# 1) maximum_of_two — функция принимает два числа и возвращает одно
# (наибольшее из двух);
# 2) maximum_of_three — функция принимает три числа и возвращает одно
# (наибольшее из трёх);
# при этом она должна использовать для сравнений первую функцию maximum_of_two.

def max_num(num_1, num_2):
    if num_1 > num_2:
        num_max = num_1
    else:
        num_max = num_2
    return num_max

num_user_1 = int(input('Введите первое число: '))
num_user_2 = int(input('Введите второе число: '))
num_max = max_num(num_user_1, num_user_2)

num_user_3 = int(input('Введите третье число: '))
num_max = max_num(num_max, num_user_3)

print('Максимальное число:', num_max)

# Задача 3. Число наоборот 2.

# Пользователь вводит два числа — N и K.
# Напишите программу,
# которая заменяет каждое число на число,
# которое получается из исходного записью его цифр в обратном порядке,
# затем складывает их,
# снова переворачивает и выводит ответ на экран.

# Пример: 

# Введите первое число: 102
# Введите второе число: 123


# Первое число наоборот: 201
# Второе число наоборот: 321

# Сумма: 522
# Сумма наоборот: 225

def reverse(number):
    n = 0
    while number > 0:
        digit = number % 10
        number //= 10
        n *= 10
        n = n + digit
    return n
a = int(input('Введите первое число: '))
b = int(input('Введите второе число: '))
print('Первое число наоборот: ', reverse(a))
print('Второе число наоборот: ', reverse(b))
sum_ = reverse(a) + reverse(b)
print('Сумма: ', sum_)
print('Сумма наоборот: ', reverse(sum_))

# Задача 4. Недоделка 2.

# Вы всё так же работаете в конторе по разработке игр и смотрите различные программы прошлого горе-программиста.
# В одной из игр для детей, связанной с мультяшной работой с числами, вам нужно было написать код согласно следующим условиям:
# программа получает на вход два числа; в первом числе должно быть не менее трёх цифр, во втором — не менее четырёх,
# иначе программа выдаёт ошибку. Если всё нормально, то в каждом числе первая и последняя цифры меняются местами,
# а затем выводится их сумма.

# И тут вы натыкаетесь на программу, которая была написана предыдущим программистом и которая как раз решает такую задачу.
# Однако старший программист попросил вас немного переписать этот код, чтобы он не выглядел так ужасно. Да и вам самим становится,
# мягко говоря, не по себе от него.

# Постарайтесь разделить логику кода на три отдельные логические части (функции):
# count_numbers — получает число и возвращает количество цифр в числе;
# change_number — получает число, меняет в нём местами первую и последнюю цифры и возвращает изменённое число;
# main — функция ничего не получает на вход, внутри она запрашивает нужные данные от пользователя,
# выполняет дополнительные проверки и вызывает функции 1 и 2 для выполнения задачи (проверки и изменения двух чисел).

# Разбейте приведённую ниже программу на функции. Повторений кода должно быть как можно меньше.
# Также сделайте, чтобы в основной части программы был только ввод чисел, затем изменённые числа и вывод их суммы.

def decomposition(temp):
    num_count = 0
    while temp > 0:
        num_count += 1
        temp //= 10
    return num_count

def reverse(first_n, num_count):
    last_digit = first_n % 10
    first_digit = first_n // 10 ** (num_count - 1)
    between_digits = first_n % 10 ** (num_count - 1) // 10
    first_n = last_digit * 10 ** (num_count - 1) + between_digits * 10 + first_digit
    return first_n

first_n = int(input("Введите первое число: "))
num_count = decomposition(first_n)
if num_count < 3:
    print("В первом числе меньше трёх цифр.")
else:
    first_n = reverse(first_n, num_count)
    print('Изменённое первое число:', first_n)
    second_n = int(input("\nВведите второе число: "))
    num_count = decomposition(second_n)

    if num_count < 4:
        print("Во втором числе меньше четырёх цифр.")
    else:
        second_n = reverse(second_n, num_count)
        print('Изменённое второе число:', second_n)
        print('\nСумма чисел:', first_n + second_n)

# Задача 5. Маятник.

# Известно, что амплитуда качающегося маятника с каждым разом затухает
# на 8,4% от амплитуды прошлого колебания. 
# Если качнуть маятник,
# то, строго говоря, он не остановится никогда, 
# просто амплитуда будет постоянно уменьшаться до тех пор, 
# пока мы не сочтём такой маятник остановившимся. 

# Напишите программу, 
# определяющую, сколько раз качнётся маятник, прежде чем он, по нашему мнению, остановится. 

# Программа получает на вход
# начальную амплитуду колебания в сантиметрах 
# и конечную амплитуду его колебаний,
# которая считается остановкой маятника. 

# Обеспечьте контроль ввода.

# Пример:

# Введите начальную амплитуду: 1
# Введите амплитуду остановки: 0.1

# Маятник считается остановившимся через 27 колебаний

def pendulum_stop(ampl_start, ampl_finish):
    count = 0
    while ampl_start > ampl_finish:
        count +=1
        ampl_start -= ampl_start * 0.084
    return count

ampl_start = float(input('Введите начальную амплитуду: '))
ampl_finish = float(input('Введите амплитуду остановки: '))

frequency = pendulum_stop(ampl_start, ampl_finish)
print(f'Маятник считается остановившимся через {frequency} колебаний')

# Задача 6. Яйца.

# В рамках программы колонизации Марса
# компания «Спейс Инжиниринг» вывела особую породу черепах,
# которые, по задумке, должны размножаться, откладывая яйца в марсианском грунте.
# Откладывать яйца слишком близко к поверхности опасно из-за радиации,
# а слишком глубоко — из-за давления грунта и недостатка кислорода.
# Вообще, факторов очень много,
# но специалисты проделали большую работу и предположили,
# что уровень опасности для черепашьих яиц рассчитывается по формуле
# D = x**3 − 3x**2 − 12x + 10,
# где x — глубина кладки в метрах,
# а D — уровень опасности в условных единицах.
# 
# Для тестирования гипотезы
# нужно взять пробу грунта на безопасной, согласно формуле, глубине.
# 
# Напишите программу,
# находящую такое значение глубины "х", при котором уровень опасности как можно более близок к нулю.
# На вход программе подаётся максимально допустимое отклонение уровня опасности от нуля,
# а программа должна рассчитать приблизительное значение "х",
# удовлетворяющее этому отклонению.
# 
# Известно, что глубина точно больше нуля и меньше четырёх метров.
# 
# Обеспечьте контроль ввода.
# 
# Пример:
# Введите максимально допустимый уровень опасности: 0.01
# 
# Приблизительная глубина безопасной кладки: 0.732421875 м

dangerLevel = float(input('Введите максимально допустимый уровень опасности: '))
depthUp = 0
depthDown = 4
depth = depthUp + (depthDown - depthUp) / 2
Danger = depth ** 3 - 3 * depth ** 2 - 12 * depth + 10

if dangerLevel < 0:
    print('Ошибка: максимально допустимый уровень опасности - абсолютная величина и должна быть больше нуля.')
else:
    while abs(Danger) > dangerLevel:
        if Danger > 0:
            depthUp = depth
        else:
            depthDown = depth
        depth = depthUp + (depthDown - depthUp) / 2
        Danger = depth ** 3 - 3 * depth ** 2 - 12 * depth + 10

print('Приблизительная глубина безопасной кладки: ', depth, 'м')